<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>schedule上</title>
        <!-- Google Tag Manager -->
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NBTSW2TH');</script>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-N6K15VE892"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-N6K15VE892');
        </script>
        <!-- End Google Tag Manager -->

        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NBTSW2TH"
                      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 最近更新</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> golang</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">2.1.</strong> golang基础数据结构</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../go/base/1.channel详解.html"><strong aria-hidden="true">2.1.1.</strong> channel</a></li><li class="chapter-item "><a href="../../go/base/2.time详解.html"><strong aria-hidden="true">2.1.2.</strong> time</a></li><li class="chapter-item "><a href="../../go/base/3.select详解.html"><strong aria-hidden="true">2.1.3.</strong> select</a></li><li class="chapter-item "><a href="../../go/base/4.sync上.html"><strong aria-hidden="true">2.1.4.</strong> sync上</a></li><li class="chapter-item "><a href="../../go/base/5.sync下.html"><strong aria-hidden="true">2.1.5.</strong> sync下</a></li><li class="chapter-item "><a href="../../go/base/6.map详解.html"><strong aria-hidden="true">2.1.6.</strong> map</a></li><li class="chapter-item "><a href="../../go/base/7.slice详解.html"><strong aria-hidden="true">2.1.7.</strong> slice</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> golang runtime源码分析</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../go/runtime/1.golang源码阅读-go-start.html"><strong aria-hidden="true">2.2.1.</strong> go启动流程</a></li><li class="chapter-item expanded "><a href="../../go/runtime/2.golang源码阅读-schedule1.html" class="active"><strong aria-hidden="true">2.2.2.</strong> schedule上</a></li><li class="chapter-item "><a href="../../go/runtime/3.golang源码阅读-schedule2.html"><strong aria-hidden="true">2.2.3.</strong> schedule下</a></li><li class="chapter-item "><a href="../../go/runtime/4.golang源码阅读-sysmon详解.html"><strong aria-hidden="true">2.2.4.</strong> sysmon详解</a></li><li class="chapter-item "><a href="../../go/runtime/5.golang源码阅读-内存分配.html"><strong aria-hidden="true">2.2.5.</strong> 内存分配</a></li><li class="chapter-item "><a href="../../go/runtime/6.golang源码阅读-netpoll详解.html"><strong aria-hidden="true">2.2.6.</strong> netpoll详解</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.3.</strong> golang杂项</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">2.3.1.</strong> 长连接无损迁移</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 队列</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">3.1.</strong> kafka</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 云原生</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">4.1.</strong> 前置知识</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../k8s/base/k8s核心对象.html"><strong aria-hidden="true">4.1.1.</strong> k8s核心对象</a></li><li class="chapter-item "><a href="../../k8s/base/docker详解.html"><strong aria-hidden="true">4.1.2.</strong> docker原理</a></li><li class="chapter-item "><a href="../../k8s/base/pod详解.html"><strong aria-hidden="true">4.1.3.</strong> pod详解</a></li><li class="chapter-item "><a href="../../k8s/base/k8s-schedule详解.html"><strong aria-hidden="true">4.1.4.</strong> schedule</a></li><li class="chapter-item "><a href="../../k8s/base/apiserver访问控制.html"><strong aria-hidden="true">4.1.5.</strong> apiserver访问控制</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.2.</strong> 网关</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">4.2.1.</strong> traefik</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../gateway/traefik/1.traefik基础概念.html"><strong aria-hidden="true">4.2.1.1.</strong> traefik基础概念</a></li><li class="chapter-item "><a href="../../gateway/traefik/4.traefik启动流程源码分析.html"><strong aria-hidden="true">4.2.1.2.</strong> traefik启动流程</a></li><li class="chapter-item "><a href="../../gateway/traefik/5.traefik-EntryPoints详解上.html"><strong aria-hidden="true">4.2.1.3.</strong> traefik-EntryPoints详解</a></li><li class="chapter-item "><a href="../../gateway/traefik/6.traefik-router详解.html"><strong aria-hidden="true">4.2.1.4.</strong> traefik-router详解</a></li><li class="chapter-item "><a href="../../gateway/traefik/7.traefik-services详解.html"><strong aria-hidden="true">4.2.1.5.</strong> traefik-services详解</a></li><li class="chapter-item "><a href="../../gateway/traefik/8.traefik-provider详解.html"><strong aria-hidden="true">4.2.1.6.</strong> traefik-provider详解</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.3.</strong> serviceMesh</div></li><li class="chapter-item "><div><strong aria-hidden="true">4.4.</strong> k8s控制器源码分析</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../k8s/controller/replicaset详解.html"><strong aria-hidden="true">4.4.1.</strong> replicaset详解</a></li><li class="chapter-item "><a href="../../k8s/controller/deploy详解.html"><strong aria-hidden="true">4.4.2.</strong> deploy详解</a></li><li class="chapter-item "><a href="../../k8s/controller/endpoint详解.html"><strong aria-hidden="true">4.4.3.</strong> endpoint详解</a></li><li class="chapter-item "><a href="../../k8s/controller/services详解.html"><strong aria-hidden="true">4.4.4.</strong> services详解</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.5.</strong> k8s cni源码分析</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../k8s/cni/cni详解.html"><strong aria-hidden="true">4.5.1.</strong> cni基础</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.6.</strong> k8s cri源码分析</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 网络</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../network/tcp-1-环境.html"><strong aria-hidden="true">5.1.</strong> 环境</a></li><li class="chapter-item "><a href="../../network/icmp.html"><strong aria-hidden="true">5.2.</strong> icmp协议</a></li><li class="chapter-item "><a href="../../network/tcp-2-三次握手.html"><strong aria-hidden="true">5.3.</strong> tcp三次握手</a></li><li class="chapter-item "><a href="../../network/tcp压测客户端.html"><strong aria-hidden="true">5.4.</strong> tcp压测</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 杂项</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../other/linux1-ssh连接失败.html"><strong aria-hidden="true">6.1.</strong> ssh连接失败</a></li><li class="chapter-item "><a href="../../other/freeswitch_install.html"><strong aria-hidden="true">6.2.</strong> freeswitch安装</a></li><li class="chapter-item "><a href="../../other/freeswitch搭建呼叫中心-1方案设计.html"><strong aria-hidden="true">6.3.</strong> 呼叫中心设计</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> nginx</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../gateway/nginx/nginx1-搭建调试环境.html"><strong aria-hidden="true">7.1.</strong> 开发环境</a></li><li class="chapter-item "><a href="../../gateway/nginx/nginx2-基础架构.html"><strong aria-hidden="true">7.2.</strong> 基础架构</a></li><li class="chapter-item "><a href="../../gateway/nginx/nginx3-基础数据结构.html"><strong aria-hidden="true">7.3.</strong> 基础数据结构</a></li><li class="chapter-item "><a href="../../gateway/nginx/nginx4-内存管理.html"><strong aria-hidden="true">7.4.</strong> 内存管理</a></li><li class="chapter-item "><a href="../../gateway/nginx/nginx5-http.html"><strong aria-hidden="true">7.5.</strong> http</a></li><li class="chapter-item "><a href="../../gateway/nginx/nginx6-手写hello-handler.html"><strong aria-hidden="true">7.6.</strong> 手写handler</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="1-linux-cfs调度"><a class="header" href="#1-linux-cfs调度">1 linux cfs调度</a></h3>
<p>在讲go调度前,我们大概linux进程调度是怎么做的,不感兴趣可跳到章节2,不影响整体阅读 感兴趣的建议阅读<br />
<a href="&#x27;http://arthurchiao.art/blog/linux-cfs-design-and-implementation-zh/#11-cfs%E8%BF%9B%E7%A8%8Btask%E7%9A%84%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6&#x27;">Linux CFS 调度器：原理、设计与内核实现</a><br />
<a href="&#x27;https://www.kernel.org/doc/html/next/scheduler/sched-design-CFS.html&#x27;">内核CFS文档</a></p>
<h3 id="11-csf概述"><a class="header" href="#11-csf概述">1.1 csf概述</a></h3>
<p><a href="&#x27;https://www.kernel.org/doc/html/next/scheduler/sched-design-CFS.html&#x27;">CFS</a> Completely Fair Scheduler简称，即完全公平调度器
假如我们有一个cpu，有100%的使用权,有两个task在运行,cgroup设定各使用50%,cfs则负责讲cpu时间片分给这两个task(调度线程)<br />
所以cfs就是维护进程时间方面的平衡，给进程分配相当数量的处理器</p>
<h3 id="12-cfs大概实现原理"><a class="header" href="#12-cfs大概实现原理">1.2 cfs大概实现原理</a></h3>
<p>所有需要调度的进程(也可以是线程)都被存放在vruntime红黑树上,值为进程的虚拟运行时间,调度后会根据公式
vruntime = 实际运行时间*1024 / 进程权重来更新值,即插入红黑树最右侧,每次调度都会从最左侧取值</p>
<!--more-->
<h2 id="2-go-schedule"><a class="header" href="#2-go-schedule">2 go schedule</a></h2>
<p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw">官方gmp设计文档</a>
下面让我们来看下go schdule中相关的概念,即gmp</p>
<ul>
<li>g 用户态线程,代表一个goroutine,go中调度单位,主要包含当前执行的栈信息,以及当前goroutine的状态</li>
<li>m 内核线程,就是被上文cfs调度的任务</li>
<li>p 简单理解成队列,存放g需要被调度的资源信息,每个调度g的m都由一个p,阻塞或系统调用时间过长的m除外,会解绑p且创建新的m与该p绑定</li>
<li>sched</li>
</ul>
<p>我们先思考几个问题</p>
<ul>
<li>我们有10个待执行的g，4个m如何调度，即g&gt;m</li>
<li>我们有两个g,4个m,即g&lt;m，则会存在m空闲</li>
</ul>
<p>所以我们的调度器得知道所有m的状态,分配好每个m对应的g,<br />
在go 1.0版本的时候,是多线程调度器,g存在一个全局队列,所有的m都是去全局队列拿g,这种情况可以很好的让每个m拿到对应的g，最大问题是拿g的时候锁竞争严重<br />
在go1.11版本引入了<a href="&#x27;http://supertech.csail.mit.edu/papers/steal.pdf&#x27;">word-stealing调度算法</a>,上文文档有介绍该机制,引入了gmp模型,这时候每一个m对应每一个p,又引入了新问题,假如一个g长时间占用m,该m上的其它g得不到调用<br />
在go1.12版本中引入了协作抢占试调用,1.14版本修改成了信号量抢占调用,下文我们专门讲解基于信号量的抢占式调用</p>
<p><img src="img.png" alt="img.png" />
大概的调度模型我们了解了,下面我们来看下m的细节,简单理解就是p有任务就拿,没有就去别的p偷，再没有就去全局偷,实在没事干就自旋,如果系统调用达到一定时间后<br />
自身的p就会被拿走找有没有自旋的m,有就给过去,没有就创建新的,下面我们来看看m的代码</p>
<h3 id="21-gmp中的主要结构"><a class="header" href="#21-gmp中的主要结构">2.1 gmp中的主要结构</a></h3>
<p><img src="img_2.png" alt="img_2.png" />
m就是操作系统的线程,我们先看下几个重要的字段</p>
<pre><code class="language-go">// src/runtime/runtime2.go
type m struct {
    // 用于执行调度指令的g
	g0      *g     // goroutine with scheduling stack
    //处理signal的g
	gsignal       *g                // signal-handling g
	//线程本地存储
	tls           [tlsSlots]uintptr // thread-local storage (for x86 extern register)
	//当前运行的g
	curg          *g       // current running goroutine
	
	// 用于执行 go 代码的处理器p
	p             puintptr // attached p for executing go code (nil if not executing go code)
	//暂存的处理的
	nextp         puintptr
	//执行系统调用之前使用线程的处理器p
	oldp          puintptr // the p that was attached before executing a syscall
	
    //m没有运行work,正在寻找work即表示自身的自旋和非自旋状态
    spinning      bool // m is out of work and is actively looking for work
	
    //cgo相关
    ncgocall      uint64        // number of cgo calls in total
    ncgo          int32         // number of cgo calls currently in progress
    cgoCallersUse atomic.Uint32 // if non-zero, cgoCallers in use temporarily
    cgoCallers    *cgoCallers   // cgo traceback if crashing in cgo call
	//将自己与其他的 M 进行串联,即链表
	alllink     *m			// 在 allm 上
}
</code></pre>
<p>我们再来看看p的结构m，简单来说,p存在的意义是实现工作窃取（work stealing）算法，就是存放g的给m使用的本地队列,
p主要存放了可被调度的goroutine,以及用于m执行的内存分配(不需要加锁)。
上有侵</p>
<pre><code class="language-go">// src/runtime/runtime2.go
// 其余很多字段都删减了,仅保留关键字段
type p struct {
	id          int32
	//p的状态
	status      uint32 // one of pidle/prunning/...
	//p链表
	link        puintptr
	//链接到m
	m           muintptr   // back-link to associated m (nil if idle)
	//go的内存分配相关,后文我们将会详细讲解
	mcache      *mcache
	pcache      pageCache

	//不同大小的可用的 defer 结构池
	deferpool    []*_defer // pool of available defer structs (see panic.go)
	deferpoolbuf [32]*_defer


	//可运行的goroutine队列,无锁访问
	// Queue of runnable goroutines. Accessed without lock.
	runqhead uint32
	runqtail uint32
	runq     [256]guintptr
	
	//简单来说就是插队的g
	// runnext, if non-nil, is a runnable G that was ready'd by
	// the current G and should be run next instead of what's in
	// runq if there's time remaining in the running G's time
	// slice. It will inherit the time left in the current time
	// slice. If a set of goroutines is locked in a
	// communicate-and-wait pattern, this schedules that set as a
	// unit and eliminates the (potentially large) scheduling
	// latency that otherwise arises from adding the ready'd
	// goroutines to the end of the run queue.
	//
	// Note that while other P's may atomically CAS this to zero,
	// only the owner P can CAS it to a valid G.
	runnext guintptr

	//可用的g状态链表
	// Available G's (status == Gdead)
	gFree struct {
		gList
		n int32
	}

	//todo 结合后面的发送数据详解
	sudogcache []*sudog
	sudogbuf   [128]*sudog

	//go内存分配的span,在内存分配文章详细讲解
	// Cache of mspan objects from the heap.
	mspancache struct {
		// We need an explicit length here because this field is used
		// in allocation codepaths where write barriers are not allowed,
		// and eliminating the write barrier/keeping it eliminated from
		// slice updates is tricky, more so than just managing the length
		// ourselves.
		len int
		buf [128]*mspan
	}

	//优先被调度
	// preempt is set to indicate that this P should be enter the
	// scheduler ASAP (regardless of what G is running on it).
	preempt bool

}
</code></pre>
<p>下面我们再简单看看g的结构</p>
<pre><code class="language-go">// src/runtime/runtime2.go
type g struct {
	//存放栈内存 边界为[lo, hi)
	//type stack struct {
	//    lo uintptr 
	//    hi uintptr
	//}
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic    *_panic // innermost panic - offset known to liblink
	_defer    *_defer // innermost defer
	//当前的m
	m         *m      // current m; offset known to arm liblink
	sched     gobuf
    //被唤醒时传递的参数
	param        unsafe.Pointer
	atomicstatus atomic.Uint32
	stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid         uint64
	schedlink    guintptr

	//抢占信号
	preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt
}
</code></pre>
<p>g主要就是定义了执行栈,以及调试等,执行的时候讲参数拷贝, 保存执行函数的入口地址<br />
下面我们在来看看sched的结构 
sched主要管理p,全局的g队列,defer池,以及m</p>
<pre><code class="language-go">// src/runtime/runtime2.go
type schedt struct {
	lock mutex
	
	//m相关
	//自旋的m
	midle        muintptr // idle m's waiting for work
	//自旋的m数
	nmidle       int32    // number of idle m's waiting for work
	nmidlelocked int32    // number of locked m's waiting for work
	//已创建的m和下一个mid,及序号表示mid
	mnext        int64    // number of m's that have been created and next M ID
	maxmcount    int32    // maximum number of m's allowed (or die)
	nmsys        int32    // number of system m's not counted for deadlock
	nmfreed      int64    // cumulative number of freed m's

	ngsys atomic.Int32 // number of system goroutines

	//空闲p链表
	pidle        puintptr // idle p's
	//空闲p数量
	npidle       atomic.Int32
	//自旋m的数量
	nmspinning   atomic.Int32  // See &quot;Worker thread parking/unparking&quot; comment in proc.go.

	//全局队列
	// Global runnable queue.
	runq     gQueue
	runqsize int32
	
	// Global cache of dead G's.
	gFree struct {
		lock    mutex
		stack   gList // Gs with stacks //有栈的g链表
		noStack gList // Gs without stacks //没栈的g链表
		n       int32
	}

	//一集缓存,上文中p结构体上有二级缓存
	// Central cache of sudog structs.
	sudoglock  mutex
	sudogcache *sudog

	// Central pool of available defer structs.
	deferlock mutex
	deferpool *_defer

	// freem is the list of m's waiting to be freed when their
	// m.exited is set. Linked through m.freelink.
	freem *m
	
}
</code></pre>
<p>在go启动流程中,我们了解到了schedinit,根据上文的gmp结构,我们看下关于调度器的初始化</p>
<pre><code class="language-go">// src/runtime/proc.go
// The bootstrap sequence is:
//
//	call osinit
//	call schedinit
//	make &amp; queue new G
//	call runtime·mstart
//
// The new G calls runtime·main.
func schedinit() {
    //m初始化
    mcommoninit(gp.m, -1)
    //p的初始化
    if procresize(procs) != nil {
        throw(&quot;unknown runnable goroutine during bootstrap&quot;)
    }
}
</code></pre>
<h4 id="m的初始化"><a class="header" href="#m的初始化">m的初始化</a></h4>
<pre><code class="language-go">// src/runtime/proc.go
func mcommoninit(mp *m, id int64) {
	gp := getg()

	//不是g0堆栈信息不展示给用户
	// g0 stack won't make sense for user (and is not necessary unwindable).
	if gp != gp.m.g0 {
		callers(1, mp.createstack[:])
	}

	lock(&amp;sched.lock)
	
	if id &gt;= 0 {
		mp.id = id
	} else {
		//更新m的数量以及id
		mp.id = mReserveID()
	}
    //栈相关
	lo := uint32(int64Hash(uint64(mp.id), fastrandseed))
	hi := uint32(int64Hash(uint64(cputicks()), ^fastrandseed))
	if lo|hi == 0 {
		hi = 1
	}
	// Same behavior as for 1.17.
	// TODO: Simplify this.
	if goarch.BigEndian {
		mp.fastrand = uint64(lo)&lt;&lt;32 | uint64(hi)
	} else {
		mp.fastrand = uint64(hi)&lt;&lt;32 | uint64(lo)
	}

    //初始化一个新的m,子线程
	mpreinit(mp)
	//信号处理相关
	if mp.gsignal != nil {
		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + stackGuard
	}

    // 添加到 allm 中，从而当它刚保存到寄存器或本地线程存储时候 GC 不会释放 g.m
	// Add to allm so garbage collector doesn't free g-&gt;m
	// when it is just in a register or thread-local storage.
	mp.alllink = allm

	// NumCgoCall() iterates over allm w/o schedlock,
	// so we need to publish it safely.
	atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))
	unlock(&amp;sched.lock)

	//cgo相关
	// Allocate memory to hold a cgo traceback if the cgo call crashes.
	if iscgo || GOOS == &quot;solaris&quot; || GOOS == &quot;illumos&quot; || GOOS == &quot;windows&quot; {
		mp.cgoCallers = new(cgoCallers)
	}
}
</code></pre>
<h4 id="p的初始化"><a class="header" href="#p的初始化">p的初始化</a></h4>
<p>简单的描述下干了哪些事</p>
<ul>
<li>按找nprocs的数量调整allp的大小(runtime.GOMAXPROCS())，并且初始化部分p</li>
<li>如果当前p里还有g,没有被移除,讲p状态设置未_Prunning,否则将第一个p给当前的m绑定</li>
<li>从allp移除不需要的p,将释放的p队列的任务扔进全局队列</li>
<li>最后挨个检查p,将没有任务的p放入idle队列,并将初当前p且没有任务的p连成链表
p的状态分别为_Pidle，_Prunning，_Psyscall，_Pgcstop，_Pdead</li>
<li>_Pidle 未运行g的p</li>
<li>_Prunning 已经被m绑定</li>
<li>_Psyscall  没有运行用户代码,与系统调用的m解绑后的状态</li>
<li>_Pgcstop  P因gc STW 而停止</li>
<li>_Pdead GOMAXPROCS收缩不需要这个p了,逻辑我们下文有讲</li>
</ul>
<pre><code class="language-go">func procresize(nprocs int32) *p {
    //获取p的个数
	old := gomaxprocs
	if old &lt; 0 || nprocs &lt;= 0 {
		throw(&quot;procresize: invalid arg&quot;)
	}
	if traceEnabled() {
		traceGomaxprocs(nprocs)
	}

	//更新统计信息,记录此次修改gomaxprocs的时间
	// update statistics
	now := nanotime()
	if sched.procresizetime != 0 {
		sched.totaltime += int64(old) * (now - sched.procresizetime)
	}
	sched.procresizetime = now

	maskWords := (nprocs + 31) / 32

    // 必要时增加 allp
    // 这个时候本质上是在检查用户代码是否有调用过 runtime.MAXGOPROCS 调整 p 的数量
    // 此处多一步检查是为了避免内部的锁，如果 nprocs 明显小于 allp 的可见数量（因为 len）
    // 则不需要进行加锁
	// Grow allp if necessary.
	if nprocs &gt; int32(len(allp)) {
		//与 retake 同步，它可以同时运行，因为它不在 P 上运行
		// Synchronize with retake, which could be running
		// concurrently since it doesn't run on a P.
		lock(&amp;allpLock)
		if nprocs &lt;= int32(cap(allp)) {
			//nprocs变小,则只保留allp数组里0-nprocs个p
			allp = allp[:nprocs]
		} else {
			//调大创建新的p
			nallp := make([]*p, nprocs)
			//保证旧p不被丢弃
			// Copy everything up to allp's cap so we
			// never lose old allocated Ps.
			copy(nallp, allp[:cap(allp)])
			allp = nallp
		}

		if maskWords &lt;= int32(cap(idlepMask)) {
			idlepMask = idlepMask[:maskWords]
			timerpMask = timerpMask[:maskWords]
		} else {
			nidlepMask := make([]uint32, maskWords)
			// No need to copy beyond len, old Ps are irrelevant.
			copy(nidlepMask, idlepMask)
			idlepMask = nidlepMask

			ntimerpMask := make([]uint32, maskWords)
			copy(ntimerpMask, timerpMask)
			timerpMask = ntimerpMask
		}
		unlock(&amp;allpLock)
	}

	//初始化新的p
	// initialize new P's
	for i := old; i &lt; nprocs; i++ {
		pp := allp[i]
		if pp == nil {
			pp = new(p)
		}
		//具体初始化流程 我们会在下文讲解
		pp.init(i)
		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
	}
	
	gp := getg()
	//如果当前的p的id(第一个p id = 1)大于调整后的p的数量,一般指处理器数量
	if gp.m.p != 0 &amp;&amp; gp.m.p.ptr().id &lt; nprocs {
		// continue to use the current P
		gp.m.p.ptr().status = _Prunning
		gp.m.p.ptr().mcache.prepareForSweep()
	} else {
		// release the current P and acquire allp[0].
		//
		// We must do this before destroying our current P
		// because p.destroy itself has write barriers, so we
		// need to do that from a valid P.
		if gp.m.p != 0 {
			if traceEnabled() {
				// Pretend that we were descheduled
				// and then scheduled again to keep
				// the trace sane.
				traceGoSched()
				traceProcStop(gp.m.p.ptr())
			}
			gp.m.p.ptr().m = 0
		}
		//切换到p0执行
		gp.m.p = 0
		pp := allp[0]
		pp.m = 0
		pp.status = _Pidle
		//将p0绑定到当前m
		acquirep(pp)
		if traceEnabled() {
			traceGoStart()
		}
	}
    //gmp已经被设置,不需要mcache0引导
	// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
	mcache0 = nil

	//释放未使用的p资源
	// release resources from unused P's
	for i := nprocs; i &lt; old; i++ {
		pp := allp[i]
		pp.destroy()
		// can't free P itself because it can be referenced by an M in syscall
	}

	// Trim allp.
	if int32(len(allp)) != nprocs {
		lock(&amp;allpLock)
		allp = allp[:nprocs]
		idlepMask = idlepMask[:maskWords]
		timerpMask = timerpMask[:maskWords]
		unlock(&amp;allpLock)
	}

	var runnablePs *p
	for i := nprocs - 1; i &gt;= 0; i-- {
		pp := allp[i]
		if gp.m.p.ptr() == pp {
			continue
		}
		pp.status = _Pidle
		//在本地队列里没有g
		if runqempty(pp) {
            //放入_Pidle队列里
			pidleput(pp, now)
		} else {
            //p队列里有g,代表有任务,绑定一个m
			pp.m.set(mget())
            //构建可运行的p链表
			pp.link.set(runnablePs)
			runnablePs = pp
		}
	}
	stealOrder.reset(uint32(nprocs))
	var int32p *int32 = &amp;gomaxprocs // make compiler check that gomaxprocs is an int32
	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))
	if old != nprocs {
		//通知限制器p数量改了
		// Notify the limiter that the amount of procs has changed.
		gcCPULimiter.resetCapacity(now, nprocs)
	}
    //返回所有包含本地任务的链表
	return runnablePs
}
//初始化p,新创建或者之前被销毁的p
// init initializes pp, which may be a freshly allocated p or a
// previously destroyed p, and transitions it to status _Pgcstop.
func (pp *p) init(id int32) {
	// p 的 id 就是它在 allp 中的索引
	pp.id = id
	// 新创建的 p 处于 _Pgcstop 状态
	pp.status = _Pgcstop
	pp.sudogcache = pp.sudogbuf[:0]
	pp.deferpool = pp.deferpoolbuf[:0]
	pp.wbBuf.reset() 
	// 为 P 分配 cache 对象
	if pp.mcache == nil {
		//id == 0 说明这是引导阶段初始化第一个 p
		if id == 0 {
			if mcache0 == nil {
				throw(&quot;missing mcache?&quot;)
			}
			// Use the bootstrap mcache0. Only one P will get
			// mcache0: the one with ID 0.
			pp.mcache = mcache0
		} else {
			pp.mcache = allocmcache()
		}
	}
	if raceenabled &amp;&amp; pp.raceprocctx == 0 {
		if id == 0 {
			pp.raceprocctx = raceprocctx0
			raceprocctx0 = 0 // bootstrap
		} else {
			pp.raceprocctx = raceproccreate()
		}
	}
	lockInit(&amp;pp.timersLock, lockRankTimers)

	// This P may get timers when it starts running. Set the mask here
	// since the P may not go through pidleget (notably P 0 on startup).
	timerpMask.set(id)
	// Similarly, we may not go through pidleget before this P starts
	// running if it is P 0 on startup.
	idlepMask.clear(id)
}
</code></pre>
<h4 id="g-的初始化"><a class="header" href="#g-的初始化">g 的初始化</a></h4>
<p>g的状态如下,不需要记住,大概有印象就行了,不清楚的时候可以查到</p>
<ul>
<li>_Gidle  表示这个 goroutine 刚刚分配，还没有初始化</li>
<li>_Grunnable  表示这个 goroutine 在运行队列中。它当前不在执行用户代码。堆栈不被拥有。</li>
<li>_Grunning  意味着这个 goroutine 可以执行用户代码。堆栈由这个 goroutine 拥有。它不在运行队列中。它被分配了一个 M 和一个 P（g.m 和 g.m.p 是有效的）</li>
<li>_Gsyscall  表示这个 goroutine 正在执行一个系统调用。它不执行用户代码。堆栈由这个 goroutine 拥有。它不在运行队列中。它被分配了一个 m</li>
<li>_Gwaiting  表示这个 goroutine 在运行时被阻塞</li>
<li>_Gmoribund_unused 暂未使用</li>
<li>_Gdead 这个 goroutine当前未被使用。它可能刚刚退出，处于空闲列表中，或者刚刚被初始化。它不执行用户代码。它可能有也可能没有分配堆栈。 G 及其堆栈（如果有）由退出G或从空闲列表中获得G的M所有。</li>
<li>_Genqueue_unused 暂未使用</li>
<li>_Gcopystack 意味着这个 goroutine 的堆栈正在被移动</li>
<li>_Gpreempted 意味着这个 goroutine 停止了自己以进行 suspendG 抢占</li>
</ul>
<pre><code class="language-go">//gc相关的g状态,放到后面章节讲解
_Gscan          = 0x1000
_Gscanrunnable  = _Gscan + _Grunnable  // 0x1001
_Gscanrunning   = _Gscan + _Grunning   // 0x1002
_Gscansyscall   = _Gscan + _Gsyscall   // 0x1003
_Gscanwaiting   = _Gscan + _Gwaiting   // 0x1004
_Gscanpreempted = _Gscan + _Gpreempted // 0x1009
</code></pre>
<p>启动go的方法为runtime.newproc,整体流程如下</p>
<ul>
<li>调用runtime.newproc1</li>
<li>通过gfget从p.gFree上获取一个g,如果p.gFree为空,则通过sched.gFree.stack.pop()从全局队列捞一批,当p.gFree=32||sched.gFree=nil中止</li>
<li>如果没有获取到,通过malg与allgadd分配一个新的g简称newg,然后把newg放入p的runnext上</li>
<li>若runnext为空,则直接分配,若runnext不为空,则把runnext上存在的旧的g简称oldg放入p.runq即p的本地队列末尾,若runq满了</li>
<li>调用runqputslow将p.runq上的g分配一半到全局队列,同时将oldg添加到末尾</li>
</ul>
<pre><code class="language-shell">                             +---------------------+
                             |       go func       |
                             +---------------------+
                               |
                               |
                               v
                             +---------------------+
                             |  runtime.newproc1   |
                             +---------------------+
                               |
                               |
                               v
                             +---------------------+
                             |   malg &amp;&amp; allgadd   |
                             +---------------------+
                               |
                               |
                               v
+--------------+             +-------------------------------+
|    wakep     | &lt;---------- |            runqput            |
+--------------+             +-------------------------------+
                               |                      ^    ^
                               |                      |    |
                               v                      |    |
+--------------+  runnext空   +---------------------+  |    |
| pp.runq=newg | &lt;---------- |       runnext       |  |    |
+--------------+             +---------------------+  |    |
  |                            |                      |    |
  |                            | runnext非空            |    |
  |                            v                      |    |
  |                          +---------------------+  |    |
  |                          |   pp.runnext=newg   |  |    |
  |                          +---------------------+  |    |
  |                            |                      |    |
  |                            |                      |    |
  |                            v                      |    |
  |                          +---------------------+  |    |
  |                          | put oldg to pp.runq |  |    |
  |                          +---------------------+  |    |
  |                            |                      |    |
  |                            | pp.runq full         |    |
  |                            v                      |    |
  |                          +---------------------+  |    |
  |                          |     runqputslow     | -+    |
  |                          +---------------------+       |
  |                                                        |
  +--------------------------------------------------------+
</code></pre>
<pre><code class="language-go">// src/runtime/proc.go

// Create a new g running fn.
// Put it on the queue of g's waiting to run.
// The compiler turns a go statement into a call to this.
func newproc(fn *funcval) {
	//很熟悉的方法了,获取一个g
	gp := getg()
	//获取pc/ip寄存器的值
	pc := getcallerpc()
	systemstack(func() {
		//创建一个新的 g,状态为_Grunnable
		newg := newproc1(fn, gp, pc)
        //pp即我们上文中的p,该m上绑定的p
		pp := getg().m.p.ptr()
		//runqput 尝试将 g 放入本地可运行队列。如果 next 为假，runqput 将   
		//g 添加到可运行队列的尾部。如果 next 为真，则 runqput 将 g 放入 pp.runnext 槽中  
		//如果运行队列已满，则 runnext 将 g 放入全局队列。仅由所有者 P 执行。
		//我们回忆下,pp.runnext是插队的g,将在下一个调用
		runqput(pp, newg, true)
        
		//todo 暂时理解不够深刻,后续二刷
		//如果主m已经启动,尝试再添加一个 P 来执行 G
		if mainStarted {
			wakep()
		}
	})
}
</code></pre>
<p>下面我们再来看下newproc1()，即创建一个新的g</p>
<pre><code class="language-go">// Create a new g in state _Grunnable, starting at fn. callerpc is the
// address of the go statement that created this. The caller is responsible
// for adding the new g to the scheduler.
func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {
	if fn == nil {
		fatal(&quot;go of nil func value&quot;)
	}
	mp := acquirem() // disable preemption because we hold M and P in local vars.
	//获取当前m上绑定的p
	pp := mp.p.ptr()
	//根据p获取一个g,从g上的gFree取,如果没有,从全局捞一批回来(从sched.gFree里取,直到sched.gFree没有或者pp.gFree里&gt;=32为止)
	newg := gfget(pp)
	//如果没取到g(初始化是没有g的)
	if newg == nil {
		//	stackMin = 2048
		//创建2k的栈
		newg = malg(stackMin)
		//将新创建的g从_Gidle更新为_Gdead
		casgstatus(newg, _Gidle, _Gdead)
		//将_Gdead的栈添加到allg,gc不会扫描未初始化的栈
		allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.
	}
    //省略了部分各种赋值堆栈指针给调度sched,以及g
	
	//由_Gidle变成了_Gdead变成了_Grunnable
	//分配好寄存器啥的,将g从_Gdead变成_Grunnable
	casgstatus(newg, _Gdead, _Grunnable)
	//分配go id
	newg.goid = pp.goidcache
	//用于下一次go分配
	pp.goidcache++
	if raceenabled {
		//分配data race的ctx
		newg.racectx = racegostart(callerpc)
		if newg.labels != nil {
			// See note in proflabel.go on labelSync's role in synchronizing
			// with the reads in the signal handler.
			racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync))
		}
	}
	if traceEnabled() {
		traceGoCreate(newg, newg.startpc)
	}
	//恢复抢占请求
	releasem(mp)
	return newg
}
</code></pre>
<pre><code class="language-go">func runqput(pp *p, gp *g, next bool) {
	//true
	if next {
    //将newg分配到runnext,直到成功为止
	retryNext:
		oldnext := pp.runnext
		if !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
			goto retryNext
		}
		if oldnext == 0 {
			return
		}
		// Kick the old runnext out to the regular run queue.
		gp = oldnext.ptr()
	}

retry:
	h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with consumers
	t := pp.runqtail
	//如果本地队列没满的情况,将oldg分配到p的本地队列
	if t-h &lt; uint32(len(pp.runq)) {
		pp.runq[t%uint32(len(pp.runq))].set(gp)
		atomic.StoreRel(&amp;pp.runqtail, t+1) // store-release, makes the item available for consumption
		return
	}
	//本地p上的glist满了,将oldg放入全局glist
	if runqputslow(pp, gp, h, t) {
		return
	}
	// the queue is not full, now the put above must succeed
	goto retry
}

// Put g and a batch of work from local runnable queue on global queue.
// Executed only by the owner P.
//将p上的glist一次取1/2放入全局glist,同时将gp插入末尾
func runqputslow(pp *p, gp *g, h, t uint32) bool {
	var batch [len(pp.runq)/2 + 1]*g

	// First, grab a batch from local queue.
	n := t - h
	n = n / 2
	if n != uint32(len(pp.runq)/2) {
		throw(&quot;runqputslow: queue is not full&quot;)
	}
	for i := uint32(0); i &lt; n; i++ {
		batch[i] = pp.runq[(h+i)%uint32(len(pp.runq))].ptr()
	}
	if !atomic.CasRel(&amp;pp.runqhead, h, h+n) { // cas-release, commits consume
		return false
	}
	batch[n] = gp

	if randomizeScheduler {
		for i := uint32(1); i &lt;= n; i++ {
			j := fastrandn(i + 1)
			batch[i], batch[j] = batch[j], batch[i]
		}
	}

	// Link the goroutines.
	for i := uint32(0); i &lt; n; i++ {
		batch[i].schedlink.set(batch[i+1])
	}
	var q gQueue
	q.head.set(batch[0])
	q.tail.set(batch[n])

	// Now put the batch on global queue.
	lock(&amp;sched.lock)
	globrunqputbatch(&amp;q, int32(n+1))
	unlock(&amp;sched.lock)
	return true
}
</code></pre>
<p>我们来总结下创建g的过程</p>
<ul>
<li>尝试从本地p获取已经执行过的g,本地p为0则一次从全局队列捞32个,再返回p</li>
<li>如果拿不到g(初始化没有),则创建一个g,并分配线程执行栈,g处于_Gidle状态</li>
<li>创建完成后,g变成了 _Gdead，然后执行函数的入口地址跟参数, 初始化sp,等等存储一份，调用后并存储sched并将状态变为_Grunnable</li>
<li>给新创建的goroutine分配id,并将g塞入本地队列或者插入p.runnext(插队)，满了则放入p.runq末尾,p.runq也满了则同时将p的runq通过runqputslow函数</li>
<li>分一半放入全局队列</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../go/runtime/1.golang源码阅读-go-start.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../go/runtime/3.golang源码阅读-schedule2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../go/runtime/1.golang源码阅读-go-start.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../go/runtime/3.golang源码阅读-schedule2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
